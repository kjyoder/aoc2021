---
title: "Advent of Code"
output: html_notebook
---

```{r}
require(tidyverse)
```

# Day 1 - Part 1

```{r}
d <- read_csv('data/aoc-1.1.txt', col_names = 'depth')
d %>% head()
```

```{r}
d %>%
  mutate(prev = lag(depth)) %>%
  mutate(increase = case_when(
    depth > prev ~ 1,
    TRUE ~ 0
  )) %>%
  count(increase)
```

## Part 2
```{r}
d_lag1 <- d %>%
  mutate(prev = lag(depth)) %>%
  mutate(increase = case_when(
    depth > prev ~ 1,
    is.na(prev) ~ NA_real_,
    TRUE ~ 0
  ))
head(d_lag1)
```

```{r}
d3 <- d %>%
  mutate(depth2 = lag(depth),
         depth3 = lag(depth2))
head(d3)
```

```{r}
d_lag3 <- d3 %>%
  mutate(GroupSum = depth + depth2 + depth3,
         prev = lag(GroupSum))
head(d_lag3)
```

```{r}
d_lag3 %>%
  mutate(increase = case_when(
    is.na(prev) ~ NA_real_,
    GroupSum > prev ~ 1,
    TRUE ~ 0
  )) %>%
  count(increase)
```

# Day 2: Dive!

## Part 1
Take list of commands and determine final position

```{r}
d <- read_delim('data/aoc-2.txt', col_names=c('direction', 'distance'),
              delim=' ')
d %>% head()
```

```{r}
d_sum <- d %>% 
  group_by(direction) %>%
  summarize(distance = sum(distance))
d_horizontal <- d_sum %>%
  filter(direction == 'forward') %>%
  pull(distance)
d_down <- d_sum %>%
  filter(direction == 'down') %>%
  pull(distance) 
d_up <- d_sum %>%
  filter(direction == 'up') %>%
  pull(distance)
d_vertical <- d_down - d_up
(d_total <- d_horizontal * d_vertical)
```

## Part 2
Actually, we want to track `aim` which starts at 0
* `down X` *increases* aim by `X`
* `up X` *decreases* aim by `X`
* `forward X` (1) increases horizontal positional by `X` and (2) increases depth by `aim` *multiplied* by `X`

```{r}
# initialize aim and position
aim <- 0
h_pos <- 0
depth <- 0

for (i in 1:nrow(d)) {
  if (d$direction[i] == 'forward') {
    h_pos = h_pos + d$distance[i]
    depth = depth + aim * d$distance[i]
  }
  else if (d$direction[i] == 'up') aim = aim - d$distance[i]
  else if (d$direction[i] == 'down') aim = aim + d$distance[i]
}

h_pos * depth
```
# Day 3: Binary Diagnostic
```{r}
require(tidyverse)
d <- read_csv('data/aoc-3.txt',
              col_names = 'reading')
d %>% head()
```

```{r}
# split each digit into its own column
ds <- d %>%
  separate(reading, into=str_c('C',c(0:11)),
           sep=c(1:11)) %>%
  
  mutate_if(is.character, as.numeric) 
# convert to numbers, then sum columns
dsums <- ds %>% 
  colSums()
# gamma is > 500
gamma_bits <- ifelse(dsums > 500, 1, 0)
# epsilon is < 500
epsilon_bits <- ifelse(dsums < 500, 1, 0)

# convert from binary bits to decimal
gamma_rate <- 0
epsilon_rate <- 0
for (i in 1:12) {
  idx <- 13-i
  gamma_rate <- gamma_rate + gamma_bits[idx] * 2^(i-1)
  epsilon_rate <- epsilon_rate + epsilon_bits[idx] * 2^(i-1)
}
gamma_rate * epsilon_rate
```
## Part 2
Now verify `life support rating` which is `oxygen generater rating` * `CO2 scrubber rating`

**oxygen generator rating**
* determine most common value in current bit position and keep only number with that bit in that position. If `0` and `1` are equally common, keep `1`.

**CO2 scrubber rating**
* determine the least common value. If `0` and `1` are equally common, keep `0`.

After determining *bit criteria*, discard numbers which don't match the bit criteria. If you only have one number left, stop, this is the rating. Otherwise, repeat, considering next bit to the right.

```{r}
ox1 <- gamma_bits[1]
dso <- ds %>%  filter(C0 == ox1)
dso %>% count(C1)
ox2 <- 0
dso <- dso %>%  filter(C1 == ox2)
dso %>% count(C2)
ox3 <- 0
dso <- dso %>% filter(C2 == ox3)
dso %>% count(C3)
ox4 <- 1
dso <- dso %>% filter(C3 == ox4)
dso %>% count(C4)
ox5 <- 1
dso <- dso %>% filter(C4 == ox5)
dso %>% count(C5)
ox5 <- 1
dso <- dso %>% filter(C5 == ox5)
dso %>% count(C6)
ox6 <- 1
dso <- dso %>% filter(C6 == ox6)
dso %>% count(C7)
ox7 <- 1
dso <- dso %>% filter(C7 == ox7)
dso %>% count(C8)
ox8 <- 1
dso <- dso %>% filter(C8 == ox8)
dso %>% count(C9)
ox9 <- 1
dso <- dso %>% filter(C9 == ox9)
dso %>% count(C10)
ox10 <- 0
dso <- dso %>% filter(C10 == ox10)
dso %>% count(C11)
ox11 <- 1
dso <- dso %>% filter(C11 == ox11)
oxy_bits <- dso[1,]
```

```{r}
co1 <- epsilon_bits[1]
dsco <- ds %>%  filter(C0 == co1)
dsco %>% count(C1)
co2 <- 0
dsco <- dsco %>%  filter(C1 == co2)
dsco %>% count(C2)
co3 <- 1
dsco <- dsco %>% filter(C2 == co3)
dsco %>% count(C3)
co4 <- 0
dsco <- dsco %>% filter(C3 == co4)
dsco %>% count(C4)
co5 <- 1
dsco <- dsco %>% filter(C4 == co5)
dsco %>% count(C5)
co5 <- 0
dsco <- dsco %>% filter(C5 == co5)
dsco %>% count(C6)
co6 <- 0
dsco <- dsco %>% filter(C6 == co6)
dsco %>% count(C7)
co7 <- 0
dsco <- dsco %>% filter(C7 == co7)
dsco %>% count(C8)
co8 <- 0
dsco <- dsco %>% filter(C8 == co8)

co_bits <- dsco[1,]
```

```{r}
# convert from binary bits to decimal
oxy_rate <- 0
co_rate <- 0
for (i in 1:12) {
  idx <- 13-i
  oxy_rate <- oxy_rate + oxy_bits[idx] * 2^(i-1)
  co_rate <- co_rate + co_bits[idx] * 2^(i-1)
}
oxy_rate * co_rate
```

# Day 4: Giant Squid
```{r}
require(tidyverse)
draws <- read_csv('data/aoc-4_draws.txt', col_names=FALSE)
draws <- draws %>%
  pivot_longer(everything(), names_to = 'Draw', values_to = 'Number')
draws %>% head()
```

```{r}
boards <- read_delim('data/aoc-4_boards.txt', delim=" ",
                     col_names=FALSE)
n_board <- nrow(boards)/5
boards$board <- rep(1:n_board, each=5)
boards <- boards %>%
  mutate_if(is.character, as.numeric) 
boards %>% head()
```

Let's make a class to hold the board and keep track of "hits"
```{r}
B <- vector(mode = 'list', length = n_board)
hits <- matrix(rep(0,25), nrow=5)
for (i in 1:n_board) {
  b <- boards %>% 
    filter(board == i) %>%
    select(-board)
  bd <- list('bid' = i, 'board' = b, 'hits' = hits, 'score' = 0)
  class(bd) <- 'Board'
  B[[i]] <- bd
}

mark <- function(object, ...) {
  UseMethod('mark')
}

check <- function(object) {
  UseMethod('check')
}

score <- function(object, ...) {
  UseMethod('score')
}

draw <- function(object, ...) {
  UseMethod('draw')
}

mark.Board <- function(object, num) {
  # check for the given number and add it to hits if it exists
  found <- FALSE
  row <- NULL
  col <- NULL
  for (i in 1:5) {
    if (num %in% object$board[i,]) {
      row <- i
      for (j in 1:5) {
        if (num == object$board[i,j]) {
          col <- j
          found <- TRUE
        }
      }
    }
  }
  if (found) {
    object$hits[row,col] <- 1
  }
  
  return(object)
}

check.Board <- function(object) {
  bingo <- FALSE
  # check rows
  if (any(rowSums(object$hits) == 5)) {
    bingo <- TRUE
  } else if (any(colSums(object$hits) == 5)) {
    bingo <- TRUE
  }
  return(bingo)
}

score.Board <- function(object, num) {
  # sum unmarked numbers and multiply by last pulled number
  object$score <- num * sum(object$board[object$hits == 0])
  return(object)
}

draw.Board <- function(object, num) {
  object <- mark(object, num)
  bingo <- check(object)
  if (bingo) {
    object <- score(object, num)
  }
  return(object)
}
```

```{r}
all_boards <- B
winner <- FALSE
for (ii in 1:nrow(draws)) {
  pull <- draws[ii,2]
  for (bi in 1:n_board) {
    bd <- draw(all_boards[[bi]], pull)
    if (bd$score > 0) {
      print(str_c('Board ', bd$bid, ' won! Pull ', pull, ', score = ', bd$score))
      winner <- TRUE
    }
    all_boards[[bi]] <- bd
  }
  if (winner) break
}
```

## Part 2: which board wins last?
```{r}
winning_pull <- rep(0, n_board)
winning_score <- rep(0, n_board)
all_boards <- B

for (ii in 1:nrow(draws)) {
  pull <- draws[ii,2]
  for (bi in 1:n_board) {
    if (winning_pull[bi] > 0) {
      # skip if board already scored
    } else {
      bd <- draw(all_boards[[bi]], pull)
      if (bd$score > 0) {
        winning_pull[[bi]] <- ii
        winning_score[[bi]] <- bd$score
      }
      all_boards[[bi]] <- bd
    }
  }
}
```

```{r}
results <- tibble(
  pull = winning_pull,
  score = winning_score
)
results %>%
  filter(pull == max(winning_pull)) %>%
  pull(score)
```


# Day 5:
```{r}
#unlockBinding("last.warning", baseenv())
#assign("last.warning", NULL, envir = baseenv())
library(tidyverse)
```

```{r}
# read as characgter to handle ###,### format
d <- read_csv('data/aoc-5.txt', col_names=c('x1','m','y2'),
              col_types = cols(.default=col_integer(),
                               m = col_character()))
d <- d %>% 
  separate(m, into = c('y1', 'x2')) %>%
  mutate(y1 = as.numeric(y1),
         x2 = as.numeric(x2))
d %>% head()
```

Determine number of points with more than one line going through it
```{r}
summary(d)
```

```{r}
vents <- matrix(rep(0,1000*1000), nrow=1000)

h_lines <- d %>%
  filter(x1 == x2)
v_lines <- d %>%
  filter(y1 == y2)

for (i in 1:nrow(h_lines)) {
  x <- h_lines[[i,1]]
  y_range <- c(h_lines[[i,2]]:h_lines[[i,4]])
  vents[x, y_range] <- vents[x, y_range] + 1
}

for (i in 1:nrow(v_lines)) {
  y <- v_lines[[i,2]]
  x_range <- c(v_lines[[i,1]]:v_lines[[i,3]])
  vents[x_range, y] <- vents[x_range, y] + 1
}
```

```{r}
sum(vents > 1)
```

## Part 2
Don't forget diagonals!
```{r}
diags <- d %>%
  filter( (x1 != x2) & (y1 != y2))

for (i in 1:nrow(diags)) {
  x_range <- c(diags[[i,1]]:diags[[i,3]])
  y_range <- c(diags[[i,2]]:diags[[i,4]])
  for (j in 1:length(x_range)) {
    vents[x_range[j], y_range[j]] <- vents[x_range[j], y_range[j]] + 1
  }
  
}

sum(vents > 1)
```

# Day 6: Lanternfish
Assume lantern fish produce one new lanternfish every `7` days.

Model each day as *number of days until it creates a new lanternfish*, but new lanternfish need an additional 2 days to reproduce.

For instance, take a lanternfish with internal value `3`
For each subsequent day:
1. internal timer decrease to 2
2. internal timer decrease to 1
3. internal timer decrease to 0
4. internal timer reset to 6, and create new lanternfish with internal timer of 8
5. internal timer of 5, and offspring has internal timer of 7

How many lanternfish after 80 days?
```{r}
require(tidyverse)
d <- read_csv('data/aoc-6.txt', col_names=FALSE,
              col_types = cols(.default=col_integer()))
d_vals <- as.matrix(d)
d <- tibble(value = t(d_vals))
d %>% head()
```

```{r}
add_day <- function(d) {
  d2 <- d %>%
    mutate(need_new = case_when(
      value == 0 ~ 1,
      TRUE ~ 0
    )) %>%
    mutate(
      next_day = case_when(
        value == 0 ~ 6,
        TRUE ~ value - 1
      ))
  n_new <- sum(d2$need_new)
  new_v <- tibble(value = rep(8, n_new))
  new_d <- tibble(value = d2$next_day)
  new_d <- new_d %>% bind_rows(new_v)
  return(new_d)
}

d_orig <- d
n_pop <- vector(mode='numeric', length=80)
for (i in 1:80) {
  d <- add_day(d)
  n_pop[i] <- nrow(d)
}

nrow(d)
```

## Part 2: What about 256 days?
256 days is a lot of replications to run. Instead of storing the entire data frame each time, it's faster and more efficient to just count the number of fish at each stage.

```{r}
d <- d_orig
d %>% count(value)
```

At the start, there are only 5 distinct values. But we will want to track the numbers of fish from values `0` all the way up to values of `8`
```{r}
counter_init <- c(0,117,43,41,49,50,0,0,0)
sum(counter_init)
```

```{r}
add_day2 <- function(counter) {
  new_6 <- counter[1] # any new numbers to
  for (i in 1:9) {
    counter[i] <- counter[i+1]
  }
  counter[7] <- counter[7] + new_6
  counter[9] <- new_6
  return(counter)
}
```

```{r}
c <- counter_init
for (i in 1:256) {
  c <- add_day2(c)
}
sum(c)
```

