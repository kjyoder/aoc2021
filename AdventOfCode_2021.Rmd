---
title: "Advent of Code"
output: html_notebook
---

```{r}
require(tidyverse)
```

# Day 1 - Part 1

```{r}
d <- read_csv('data/aoc-1.1.txt', col_names = 'depth')
d %>% head()
```

```{r}
d %>%
  mutate(prev = lag(depth)) %>%
  mutate(increase = case_when(
    depth > prev ~ 1,
    TRUE ~ 0
  )) %>%
  count(increase)
```

## Part 2
```{r}
d_lag1 <- d %>%
  mutate(prev = lag(depth)) %>%
  mutate(increase = case_when(
    depth > prev ~ 1,
    is.na(prev) ~ NA_real_,
    TRUE ~ 0
  ))
head(d_lag1)
```

```{r}
d3 <- d %>%
  mutate(depth2 = lag(depth),
         depth3 = lag(depth2))
head(d3)
```

```{r}
d_lag3 <- d3 %>%
  mutate(GroupSum = depth + depth2 + depth3,
         prev = lag(GroupSum))
head(d_lag3)
```

```{r}
d_lag3 %>%
  mutate(increase = case_when(
    is.na(prev) ~ NA_real_,
    GroupSum > prev ~ 1,
    TRUE ~ 0
  )) %>%
  count(increase)
```

# Day 2: Dive!

## Part 1
Take list of commands and determine final position

```{r}
d <- read_delim('data/aoc-2.txt', col_names=c('direction', 'distance'),
              delim=' ')
d %>% head()
```

```{r}
d_sum <- d %>% 
  group_by(direction) %>%
  summarize(distance = sum(distance))
d_horizontal <- d_sum %>%
  filter(direction == 'forward') %>%
  pull(distance)
d_down <- d_sum %>%
  filter(direction == 'down') %>%
  pull(distance) 
d_up <- d_sum %>%
  filter(direction == 'up') %>%
  pull(distance)
d_vertical <- d_down - d_up
(d_total <- d_horizontal * d_vertical)
```

## Part 2
Actually, we want to track `aim` which starts at 0
* `down X` *increases* aim by `X`
* `up X` *decreases* aim by `X`
* `forward X` (1) increases horizontal positional by `X` and (2) increases depth by `aim` *multiplied* by `X`

```{r}
# initialize aim and position
aim <- 0
h_pos <- 0
depth <- 0

for (i in 1:nrow(d)) {
  if (d$direction[i] == 'forward') {
    h_pos = h_pos + d$distance[i]
    depth = depth + aim * d$distance[i]
  }
  else if (d$direction[i] == 'up') aim = aim - d$distance[i]
  else if (d$direction[i] == 'down') aim = aim + d$distance[i]
}

h_pos * depth
```
# Day 3: Binary Diagnostic
```{r}
require(tidyverse)
d <- read_csv('data/aoc-3.txt',
              col_names = 'reading')
d %>% head()
```

```{r}
# split each digit into its own column
ds <- d %>%
  separate(reading, into=str_c('C',c(0:11)),
           sep=c(1:11)) %>%
  
  mutate_if(is.character, as.numeric) 
# convert to numbers, then sum columns
dsums <- ds %>% 
  colSums()
# gamma is > 500
gamma_bits <- ifelse(dsums > 500, 1, 0)
# epsilon is < 500
epsilon_bits <- ifelse(dsums < 500, 1, 0)

# convert from binary bits to decimal
gamma_rate <- 0
epsilon_rate <- 0
for (i in 1:12) {
  idx <- 13-i
  gamma_rate <- gamma_rate + gamma_bits[idx] * 2^(i-1)
  epsilon_rate <- epsilon_rate + epsilon_bits[idx] * 2^(i-1)
}
gamma_rate * epsilon_rate
```
## Part 2
Now verify `life support rating` which is `oxygen generater rating` * `CO2 scrubber rating`

**oxygen generator rating**
* determine most common value in current bit position and keep only number with that bit in that position. If `0` and `1` are equally common, keep `1`.

**CO2 scrubber rating**
* determine the least common value. If `0` and `1` are equally common, keep `0`.

After determining *bit criteria*, discard numbers which don't match the bit criteria. If you only have one number left, stop, this is the rating. Otherwise, repeat, considering next bit to the right.

```{r}
ox1 <- gamma_bits[1]
dso <- ds %>%  filter(C0 == ox1)
dso %>% count(C1)
ox2 <- 0
dso <- dso %>%  filter(C1 == ox2)
dso %>% count(C2)
ox3 <- 0
dso <- dso %>% filter(C2 == ox3)
dso %>% count(C3)
ox4 <- 1
dso <- dso %>% filter(C3 == ox4)
dso %>% count(C4)
ox5 <- 1
dso <- dso %>% filter(C4 == ox5)
dso %>% count(C5)
ox5 <- 1
dso <- dso %>% filter(C5 == ox5)
dso %>% count(C6)
ox6 <- 1
dso <- dso %>% filter(C6 == ox6)
dso %>% count(C7)
ox7 <- 1
dso <- dso %>% filter(C7 == ox7)
dso %>% count(C8)
ox8 <- 1
dso <- dso %>% filter(C8 == ox8)
dso %>% count(C9)
ox9 <- 1
dso <- dso %>% filter(C9 == ox9)
dso %>% count(C10)
ox10 <- 0
dso <- dso %>% filter(C10 == ox10)
dso %>% count(C11)
ox11 <- 1
dso <- dso %>% filter(C11 == ox11)
oxy_bits <- dso[1,]
```

```{r}
co1 <- epsilon_bits[1]
dsco <- ds %>%  filter(C0 == co1)
dsco %>% count(C1)
co2 <- 0
dsco <- dsco %>%  filter(C1 == co2)
dsco %>% count(C2)
co3 <- 1
dsco <- dsco %>% filter(C2 == co3)
dsco %>% count(C3)
co4 <- 0
dsco <- dsco %>% filter(C3 == co4)
dsco %>% count(C4)
co5 <- 1
dsco <- dsco %>% filter(C4 == co5)
dsco %>% count(C5)
co5 <- 0
dsco <- dsco %>% filter(C5 == co5)
dsco %>% count(C6)
co6 <- 0
dsco <- dsco %>% filter(C6 == co6)
dsco %>% count(C7)
co7 <- 0
dsco <- dsco %>% filter(C7 == co7)
dsco %>% count(C8)
co8 <- 0
dsco <- dsco %>% filter(C8 == co8)

co_bits <- dsco[1,]
```

```{r}
# convert from binary bits to decimal
oxy_rate <- 0
co_rate <- 0
for (i in 1:12) {
  idx <- 13-i
  oxy_rate <- oxy_rate + oxy_bits[idx] * 2^(i-1)
  co_rate <- co_rate + co_bits[idx] * 2^(i-1)
}
oxy_rate * co_rate
```

# Day 4: Giant Squid
```{r}
require(tidyverse)
draws <- read_csv('data/aoc-4_draws.txt', col_names=FALSE)
draws <- draws %>%
  pivot_longer(everything(), names_to = 'Draw', values_to = 'Number')
draws %>% head()
```

```{r}
boards <- read_delim('data/aoc-4_boards.txt', delim=" ",
                     col_names=FALSE)
n_board <- nrow(boards)/5
boards$board <- rep(1:n_board, each=5)
boards <- boards %>%
  mutate_if(is.character, as.numeric) 
boards %>% head()
```

Let's make a class to hold the board and keep track of "hits"
```{r}
B <- vector(mode = 'list', length = n_board)
hits <- matrix(rep(0,25), nrow=5)
for (i in 1:n_board) {
  b <- boards %>% 
    filter(board == i) %>%
    select(-board)
  bd <- list('bid' = i, 'board' = b, 'hits' = hits, 'score' = 0)
  class(bd) <- 'Board'
  B[[i]] <- bd
}

mark <- function(object, ...) {
  UseMethod('mark')
}

check <- function(object) {
  UseMethod('check')
}

score <- function(object, ...) {
  UseMethod('score')
}

draw <- function(object, ...) {
  UseMethod('draw')
}

mark.Board <- function(object, num) {
  # check for the given number and add it to hits if it exists
  found <- FALSE
  row <- NULL
  col <- NULL
  for (i in 1:5) {
    if (num %in% object$board[i,]) {
      row <- i
      for (j in 1:5) {
        if (num == object$board[i,j]) {
          col <- j
          found <- TRUE
        }
      }
    }
  }
  if (found) {
    object$hits[row,col] <- 1
  }
  
  return(object)
}

check.Board <- function(object) {
  bingo <- FALSE
  # check rows
  if (any(rowSums(object$hits) == 5)) {
    bingo <- TRUE
  } else if (any(colSums(object$hits) == 5)) {
    bingo <- TRUE
  }
  return(bingo)
}

score.Board <- function(object, num) {
  # sum unmarked numbers and multiply by last pulled number
  object$score <- num * sum(object$board[object$hits == 0])
  return(object)
}

draw.Board <- function(object, num) {
  object <- mark(object, num)
  bingo <- check(object)
  if (bingo) {
    object <- score(object, num)
  }
  return(object)
}
```

```{r}
all_boards <- B
winner <- FALSE
for (ii in 1:nrow(draws)) {
  pull <- draws[ii,2]
  for (bi in 1:n_board) {
    bd <- draw(all_boards[[bi]], pull)
    if (bd$score > 0) {
      print(str_c('Board ', bd$bid, ' won! Pull ', pull, ', score = ', bd$score))
      winner <- TRUE
    }
    all_boards[[bi]] <- bd
  }
  if (winner) break
}
```

## Part 2: which board wins last?
```{r}
winning_pull <- rep(0, n_board)
winning_score <- rep(0, n_board)
all_boards <- B

for (ii in 1:nrow(draws)) {
  pull <- draws[ii,2]
  for (bi in 1:n_board) {
    if (winning_pull[bi] > 0) {
      # skip if board already scored
    } else {
      bd <- draw(all_boards[[bi]], pull)
      if (bd$score > 0) {
        winning_pull[[bi]] <- ii
        winning_score[[bi]] <- bd$score
      }
      all_boards[[bi]] <- bd
    }
  }
}
```

```{r}
results <- tibble(
  pull = winning_pull,
  score = winning_score
)
results %>%
  filter(pull == max(winning_pull)) %>%
  pull(score)
```


# Day 5:
```{r}
#unlockBinding("last.warning", baseenv())
#assign("last.warning", NULL, envir = baseenv())
library(tidyverse)
```

```{r}
# read as characgter to handle ###,### format
d <- read_csv('data/aoc-5.txt', col_names=c('x1','m','y2'),
              col_types = cols(.default=col_integer(),
                               m = col_character()))
d <- d %>% 
  separate(m, into = c('y1', 'x2')) %>%
  mutate(y1 = as.numeric(y1),
         x2 = as.numeric(x2))
d %>% head()
```

Determine number of points with more than one line going through it
```{r}
summary(d)
```

```{r}
vents <- matrix(rep(0,1000*1000), nrow=1000)

h_lines <- d %>%
  filter(x1 == x2)
v_lines <- d %>%
  filter(y1 == y2)

for (i in 1:nrow(h_lines)) {
  x <- h_lines[[i,1]]
  y_range <- c(h_lines[[i,2]]:h_lines[[i,4]])
  vents[x, y_range] <- vents[x, y_range] + 1
}

for (i in 1:nrow(v_lines)) {
  y <- v_lines[[i,2]]
  x_range <- c(v_lines[[i,1]]:v_lines[[i,3]])
  vents[x_range, y] <- vents[x_range, y] + 1
}
```

```{r}
sum(vents > 1)
```

## Part 2
Don't forget diagonals!
```{r}
diags <- d %>%
  filter( (x1 != x2) & (y1 != y2))

for (i in 1:nrow(diags)) {
  x_range <- c(diags[[i,1]]:diags[[i,3]])
  y_range <- c(diags[[i,2]]:diags[[i,4]])
  for (j in 1:length(x_range)) {
    vents[x_range[j], y_range[j]] <- vents[x_range[j], y_range[j]] + 1
  }
  
}

sum(vents > 1)
```

# Day 6: Lanternfish
Assume lantern fish produce one new lanternfish every `7` days.

Model each day as *number of days until it creates a new lanternfish*, but new lanternfish need an additional 2 days to reproduce.

For instance, take a lanternfish with internal value `3`
For each subsequent day:
1. internal timer decrease to 2
2. internal timer decrease to 1
3. internal timer decrease to 0
4. internal timer reset to 6, and create new lanternfish with internal timer of 8
5. internal timer of 5, and offspring has internal timer of 7

How many lanternfish after 80 days?
```{r}
require(tidyverse)
d <- read_csv('data/aoc-6.txt', col_names=FALSE,
              col_types = cols(.default=col_integer()))
d_vals <- as.matrix(d)
d <- tibble(value = t(d_vals))
d %>% head()
```

```{r}
add_day <- function(d) {
  d2 <- d %>%
    mutate(need_new = case_when(
      value == 0 ~ 1,
      TRUE ~ 0
    )) %>%
    mutate(
      next_day = case_when(
        value == 0 ~ 6,
        TRUE ~ value - 1
      ))
  n_new <- sum(d2$need_new)
  new_v <- tibble(value = rep(8, n_new))
  new_d <- tibble(value = d2$next_day)
  new_d <- new_d %>% bind_rows(new_v)
  return(new_d)
}

d_orig <- d
n_pop <- vector(mode='numeric', length=80)
for (i in 1:80) {
  d <- add_day(d)
  n_pop[i] <- nrow(d)
}

nrow(d)
```

## Part 2: What about 256 days?
256 days is a lot of replications to run. Instead of storing the entire data frame each time, it's faster and more efficient to just count the number of fish at each stage.

```{r}
d <- d_orig
d %>% count(value)
```

At the start, there are only 5 distinct values. But we will want to track the numbers of fish from values `0` all the way up to values of `8`
```{r}
counter_init <- c(0,117,43,41,49,50,0,0,0)
sum(counter_init)
```

```{r}
add_day2 <- function(counter) {
  new_6 <- counter[1] # any new numbers to
  for (i in 1:9) {
    counter[i] <- counter[i+1]
  }
  counter[7] <- counter[7] + new_6
  counter[9] <- new_6
  return(counter)
}
```

```{r}
c <- counter_init
for (i in 1:256) {
  c <- add_day2(c)
}
sum(c)
```
# Day 7: Treachery of Whales

# Day 8: Seven Segment Search
```{r}
require(tidyverse)
d <- read_delim('data/aoc-8.txt', delim=' ',
                col_names = c(str_c('V', 1:10),
                              'null',str_c('N',1:4)))
d <- d %>%
  select(-null)
d %>% head()
```
The lights are correct, but the labels are wrong.
* `1` is the only number with just 2 segments
* `7` is the only number with exactly 3 segments
* `4` is the only number with exactly 4 segments
* `8` is the only number with all 7 segments
```{r}
output <- d %>%
  select(starts_with('N')) %>%
  mutate_all(nchar)
output %>% head()
```

```{r}
output %>%
  mutate_all(funs(case_when(
    . %in% c(2, 3, 4, 7) ~ 1,
    TRUE ~ 0
  ))) %>%
  colSums() %>%
  sum()
```
## Part 2: decode all values
For sanity, the "correct" labeling of seven segments will be called:
 AAAA
B    C
B    C
 DDDD
E    F
E    F
 GGGG
 
If we only have the number of segments, there are some duplicates
2: `1`
3: `7`
4: `4`
5: `2`, `3`, `5`
6: `0`, `6`, `9`
7: `8`


* `3` is the number with 5 segments that has three matches with `7`
* AA can be identified as the segment in `7` that is not in `1`
* CC is the segment in `1` that occurs in eight segments
* FF is the segment in `1` that occurs in nine segments
* `5` is the number with 5 segments that contains FF but not CC
* `2` is the number with 5 segments that contains CC but not FF
* BB is the remaining segment in `4` that occurs in six segments
* DD is the remaining segment in `4` that occurs in seven segments
* `0` is the number of six segments that does not contain DD
* `9` is the remaining number with six segments that matches all three segments in `7` 
* `6` is the last six segment number

```{r}
# You know what, R doesn't have a good function for finding
# matching and non-matching characters between strings.
# Let's write some
get_matching <- function(x, target) {
  nx = nchar(x)
  nt = nchar(target)
  match = NULL
  
  for (ti in 1:nt) {
    tchar = substr(target, ti, ti)
    for (xi in 1:nx) {
      if (substr(x,xi,xi) == tchar) {
        match <- c(match, substr(x,xi,xi))
      }
    }
  }
  return(paste(match, sep='', collapse=''))
}

get_nonmatching <- function(x, target) {
  nx = nchar(x)
  nt = nchar(target)
  nomatch = NULL
  # check each char in x, if not in target, save
  for (xi in 1:nx) {
    xchar = substr(x, xi, xi)
    match = FALSE
    for (ti in 1:nt) {
      if (substr(target,ti,ti) == xchar) {
        match = TRUE
      }
    }
    if (!match) {
      nomatch <- c(nomatch, xchar)
    }
  }
  return(paste(nomatch, sep='', collapse=''))
  
}

alphabetize <- function(x) {
  n <- nchar(x)
  vals = substr(x,1,1)
  for (ii in 2:n) {
    vals <- c(vals, substr(x,ii,ii))
  }
  
  return(paste(sort(vals), sep='', collapse=''))
}


# write a function to score a single row
decode_row <- function(x) {
    
  # keep track of wire-path mappings
  wire_map <- tibble(A="", B="", C="",
                     D="", E="", F="",
                     G="")
  
  signals <- x %>% 
    select(starts_with('V')) %>%
    pivot_longer(everything(), values_to = 'wires') %>%
    rowwise() %>%
    mutate(wires = alphabetize(wires)) %>%
    ungroup() %>% 
    mutate(n = nchar(wires)) %>%
    mutate(Number = case_when(
      n == 2 ~ "1",
      n == 3 ~ "7",
      n == 4 ~ "4",
      n == 7 ~ "8",
      TRUE ~ NA_character_
    ))
  
  outputs <- x %>% select(starts_with('N')) %>%
    pivot_longer(everything(), values_to = 'target') %>% 
    rowwise() %>%
    mutate(target = alphabetize(target)) %>%
    ungroup() 
  
  # get the known numbers
  s1 <- signals %>% filter(Number == "1")
  s4 <- signals %>% filter(Number == "4")
  s7 <- signals %>% filter(Number == "7")
  s8 <- signals %>% filter(Number == "8")
  
  # Find 3, 5 segments with exactly three matching 7
  n5 <- signals %>% 
    filter(n == 5) %>%
    rowwise() %>%
    mutate(match7 = get_matching(wires, s7$wires)) %>%
    ungroup() %>%
    mutate(n7 = nchar(match7))
  s3_wires <- n5 %>%
    filter(n7 == 3) %>%
    pull(wires)
  
  signals <- signals %>%
    mutate(Number = case_when(
      wires == s3_wires ~ "3",
      TRUE ~ Number
    ))
  s3 <- signals %>% filter(Number == "3")
  
  # find AA (segment in 7 not in 1)
  s7 <- s7 %>%
    rowwise() %>%
    mutate(match1 = get_matching(wires, s1$wires),
           nomatch1 = get_nonmatching(wires, s1$wires))
  wire_map$A <- s7 %>% select(nomatch1) %>% pull()
  
  # find CC and FF (segment in 1 occurring 8 or 9 times, respect)
  match1 <- signals %>%
    rowwise() %>%
    mutate(match = get_matching(wires,
                                substr(s1$wires,1,1))) %>%
    count(match) %>% filter(! match %in% c("")) %>% pull(n)
  
  if (match1 == 8) {
    wire_map$C <- substr(s1$wires,1,1)
    wire_map$F <- substr(s1$wires,2,2)
  } else {
    wire_map$C <- substr(s1$wires,2,2)
    wire_map$F <- substr(s1$wires,1,1)
  }

  # Get 5 and 2
  # '5' has 5 segments and contains FF but not CC
  # '2' has 5 segments and contains CC but not FF
  n5 <- signals %>%
    filter(n == 5 & is.na(Number)) %>%
    rowwise() %>%
    mutate(matchF = get_matching(wires, wire_map$F)) %>%
    mutate(matchC = get_matching(wires, wire_map$C))
  w5 <- n5 %>% # get '5' (no c)
    filter(matchC == "") %>%
    pull(wires)
  w2 <- n5 %>% # get '2' (no)
    filter(matchF == "") %>%
    pull(wires)
  
  signals <- signals %>%
    mutate(Number = case_when(
      wires == w5 ~ "5",
      wires == w2 ~ "2",
      TRUE ~ Number
    ))
  
  n6 <- signals %>%
    filter(n == 6) %>%
    rowwise() %>%
    mutate(matchC = get_matching(wires, wire_map$C))
  # get 6, (6 segments, no C)
  w6 <- n6 %>%
    filter(matchC == "") %>%
    pull(wires)
  signals <- signals %>%
    mutate(Number = case_when(
      wires == w6 ~ "6",
      TRUE ~ Number
    ))
  # get 0 and 9
  # First get e
  #   in 6 but not 5
  wire_map$E <- get_nonmatching(
    signals %>% filter(Number == "6") %>% pull(wires), 
    signals %>% filter(Number == "5") %>% pull(wires)
    )
  # 0 has E
  # 9 doesn't
  n6 <- signals %>%
    filter(n == 6 & is.na(Number)) %>%
    rowwise() %>%
    mutate(matchE = get_matching(wires, wire_map$E)) %>%
    ungroup() %>%
    mutate(Number = case_when(
      matchE == "" ~ "9",
      TRUE ~ "0"
    )) %>%
    select(name:Number)
  w0 <- n6 %>% filter(Number == "0") %>% pull(wires)
  w9 <- n6 %>% filter(Number == "9") %>% pull(wires)
  signals <- signals %>%
    mutate(Number = case_when(
      wires == w0 ~ "0",
      wires == w9 ~ "9",
      TRUE ~ Number
    ))
  
  ss <- signals %>%
    select(wires, Number) %>%
    pivot_wider(names_from = wires,
                values_from = Number)
  
  scored <- outputs %>% 
    rowwise() %>% 
    mutate(Number = ss[target][[1]]) %>%
    ungroup() %>%
    mutate(Score = case_when(
      name == "N1" ~ as.numeric(Number) * 1000,
      name == "N2" ~ as.numeric(Number) * 100,
      name == "N3" ~ as.numeric(Number) * 10,
      name == "N4" ~ as.numeric(Number)
    ))
  
  Sum <- scored %>% pull(Score) %>% as.integer() %>% sum()
  
  return(Sum)
}

```

Let's add them up.
```{r}
vals = 0
for (i in 1:nrow(d)) {
  vals <- vals + d[i,] %>% 
    rowwise() %>% 
    mutate(Sum = decode_row(.)) %>% 
    select(Sum) %>% 
    pull()
}
vals
```


# Day 9: Smoke Basin

Find low points - places where a number is the lowest number of it's neighbors (up, down, left, right)
```{r}
require(tidyverse)
d <- read_csv('data/aoc-9.txt', col_names = 'C',
              col_types = cols(.default=col_character()))
d <- d %>% 
  separate(C, into=str_c('C',c(1:100)),
           sep=c(1:100)) %>%
  mutate_all(as.numeric)
d %>% head(2)
```

```{r}
dm <- as.matrix(d)
dim(dm)
search <- matrix(rep(0, 100*100), nrow=100)
```

```{r}
# compare values to the right
search_right = dm - cbind(rep(10,100), dm[,1:99])
# compare values to the left
search_left = dm - cbind(dm[,2:100], rep(10,100))
# compare values to the top
search_up = dm - rbind(rep(10,100), dm[1:99,])
# compare values below
search_down = dm - rbind(dm[2:100,], rep(10,100))

low_points <- dm[search_right < 0 & search_left < 0 & search_up < 0 & search_down < 0]
risk <- sum(low_points + 1)
risk
```

## Part 2: basins
```{r}
length(low_points)
```

So there are 237 distinct basins. 

```{r}
i2rc <- function(x) {
  row <- x %% 100
  col <- floor(x/100) + 1
  return(c('row'=row, 'col'=col))
}

# 1 = lowpoint, 0 = otherwise, 100x100 matrix
low_mat <- ifelse(search_right < 0 & search_left < 0 & 
                    search_up < 0 & search_down < 0, 1, 0)

# list to hold r,c pairs of lowpoints
low_idx <- vector('list', length=length(low_points))

# just the indices of low points in low_mat
low_idxs <- which(low_mat == 1)
for (i in 1:length(low_idxs)) {
  low_idx[[i]] <- i2rc(low_idxs[i])
}
```

Here's the approach I'm going to take.
1. Take a matrix of 'valleys' (all 9s replaced with 0)
2. Start with the upper left (r=1, c=1) and move left-to-right, top-to-bottom, checking for clusters
3. Checking for clusters means
3.a. If current position is non-zero, set it to -1
3.b. Recursively check neighbors up, down, left, and right
3.c. When no neighbors are left, count the number of -1 and store
4. Reset at -1 to 0

```{r}
# recursively check nodes, settings 0 to -1 on a hit
check_node <- function(r, c, mat) {
  rmax <- nrow(mat)
  cmax <- ncol(mat)
  
  if (mat[r,c] == 0 || mat[r,c] == -1) return(mat)
  # mat[r,c] was not 0 or previously set
  mat[r,c] <- -1
  
  # check the neighbors
  if (r > 2) mat <- check_node(r-1, c, mat)
  if (c > 2) mat <- check_node(r, c-1, mat)
  if (r < rmax) mat <- check_node(r+1, c, mat)
  if (c < cmax) mat <- check_node(r, c+1, mat)
  
  return(mat)
}
```

```{r}
# get matrix with 1 for < 9 and 0 for 9
# AKA 0 for edges/boundaries
valleys <- ifelse(dm < 9, 1, 0)

# prepare numerical vector to hold basin sizes
basins <- vector(mode='numeric', length=length(low_idx))

basin_id <- 1
searched <- valleys
for (r in 1:nrow(valleys)) {
  for (c in 1:ncol(valleys)) {
    # don't waste time checking empty spots
    if (searched[r,c] != 0 && searched[r,c] != -1) {
      searched <- check_node(r,c,searched)
      basins[basin_id] <- sum(searched == -1)
      searched[searched==-1] <- 0
      basin_id <- basin_id + 1
    }
  }
}
```

```{r}
big3 <- sort(basins)[(length(basins)-2) : length(basins)]
big3[1] * big3[2] * big3[3]
```

# Day 10

Find lines with syntax errors. The first syntax error then gets scored.
```{r}
require(tidyverse)
d <- read_csv('data/aoc-10.txt', col_names = 'line',
              col_types = cols(.default=col_character()))
head(d)
```

```{r}
parser <- function(line) {
  open_tokens <- c('(', '[', '{', '<')
  close_tokens <- c(')' = '(',
                    ']' = '[',
                    '}' = '{',
                    '>' = '<')
  
  if (typeof(line) == 'list') line = line[[1]]
  
  characters <- strsplit(line, '')[[1]]
  parsed <- vector(mode='list', length=length(characters))

  mid <- 0
  
  for (i in 1:length(characters)) {
    c <- characters[i]
    if (c %in% open_tokens) {
      mid = mid+1
      parsed[[mid]] <- c
    } else {
      if (close_tokens[c] == parsed[[mid]]) {
        # match
        mid = mid-1
      } else {
        return(c)
      }
    }
  }
  
  # no corrupt characters found
  if (mid > 0) {
    # incomplete
    return("0")
  } else {
    return("1")
  }
  
}


```

* `)`: 3 points.
* `]`: 57 points.
* `}`: 1197 points.
* `>`: 25137 points.

```{r}
d %>% 
  rowwise() %>% 
  mutate(scores = parser(line)) %>% 
  mutate(score = case_when(
    scores == ')' ~ 3,
    scores == ']' ~ 57,
    scores == '}' ~ 1197,
    scores == '>' ~ 25137,
    TRUE ~ NA_real_
  )) %>%
  select(score) %>%
  sum(na.rm=TRUE)
```

## Part 2:
```{r}
closer <- function(line) {
  open_tokens <- c('(', '[', '{', '<')
  close_tokens <- c(')' = '(',
                    ']' = '[',
                    '}' = '{',
                    '>' = '<')
  closer_token <- c('(' = ')',
                    '[' = ']',
                    '{' = '}',
                    '<' = '>')
  closer_score <- c(')' = 1,
                    ']' = 2,
                    '}' = 3,
                    '>' = 4)
                    
    # ): 1 point.
    # ]: 2 points.
    # }: 3 points.
    # >: 4 points.
  
  if (typeof(line) == 'list') line = line[[1]]
  
  characters <- strsplit(line, '')[[1]]
  parsed <- vector(mode='list', length=length(characters))

  mid <- 0
  
  for (i in 1:length(characters)) {
    c <- characters[i]
    if (c %in% open_tokens) {
      mid = mid+1
      parsed[[mid]] <- c
    } else {
      if (close_tokens[c] == parsed[[mid]]) {
        # match
        parsed[[mid]] <- NULL
        mid = mid-1
      }
    }
  }
  
  score <- 0
  for (ii in mid:1) {
    c <- parsed[[ii]]
    score <- score * 5
    # get closer token
    score <- score + closer_score[closer_token[c]]
    
    # ): 1 point.
    # ]: 2 points.
    # }: 3 points.
    # >: 4 points.
    
  }
  return(score)
}
```

```{r}
scores <- d %>% 
  rowwise() %>% 
  mutate(parsed = parser(line)) %>% 
  filter(parsed == 0) %>% 
  mutate(score = closer(line)) %>%
  ungroup() %>%
  select(score) %>%
  arrange(score) %>%
  pull()

scores[ceiling(length(scores)/2)]
```

# Day 11: Dumbo Octopus

Octopi have power levels from 0 to 9.

Step 1a: energy level of each octopus increases by 1
Step 1b: every octopus at > 9 flashes
Step 1c: every octopus that was exposed to a flash (4d) increases
Step 1d: every octopus > 9 flashes
Step 1e: every octopus that flashed resets to 0

Rule: An octopus can never flash more than once per step
```{r}
require(tidyverse)
d <- read_csv('data/aoc-11.txt', col_names='oct',
              col_types=cols(.default=col_character()))
d2 <- read_csv('data/aoc-11_sample.txt', col_names='oct',
              col_types=cols(.default=col_character()))
d %>% head()
```

```{r}
dm <- d %>% 
  separate(oct, str_c('0', 1:10), sep=1:10) %>%
  mutate_all(as.numeric) %>%
  as.matrix()
dm

dm2 <- d2 %>% 
  separate(oct, str_c('0', 1:10), sep=1:10) %>%
  mutate_all(as.numeric) %>%
  as.matrix()
```

```{r}
push_flash <- function(mat, target, flashed=NULL) {
  #print(str_c('incrementing ', target))
  # convert to row and column
  r <- target %% nrow(mat)
  if (r == 0) {
    r <- nrow(mat)
  }
  c <- ceiling(target / nrow(mat))
  
  inc <- tibble(
    rows = rep(c(r-1, r, r+1), 3),
    cols = rep(c(c-1, c, c+1), each=3)
  ) %>%
    filter(rows > 0 & rows <= nrow(mat)) %>%
    filter(cols > 0 & cols <= ncol(mat)) %>%
    filter(! (rows == r & cols == c ) ) %>%
    mutate(to_flash = rows + (cols-1)*nrow(mat)) %>%
    filter(! to_flash %in% flashed)
  
  to_flash <- inc$to_flash
  
  for (i in to_flash) {
    mat[i] <- mat[i]+ 1
  }
  
  return(mat)
}

check_flash <- function(mat, flashes=0, flashed=NULL) {
  
  # find octopi that will flash
  flashing <- which(mat > 9)
  
  # if no flashes, return
  if (length(flashing) == 0) {
    out <- list('mat'=mat, 'flashes'=flashes, 'flashed'=flashed)
    return(out)
  }
  
  # keep track of the number of octopi that have flashed ever
  flashes <- flashes + length(flashing)
  
  # flash octopi that are above 9
  for (fid in flashing) {
    #print(str_c('flashing ', fid))
    #m0 <- mat
    mat <- push_flash(mat, fid, flashed)
    #print(mat - m0)
    #print(mat)
  }
  
  # update flashed
  flashed <- append(flashed, flashing)
  mat[flashed] <- 0
  
  if (length(which(mat > 9)) > 0) {
    #print('Cascading...')
    # flash any octopi that are now above 9
    res <- check_flash(mat, flashes, flashed)
  
    # reset all flashed octopi this step
    res$mat[flashed] <- 0
    out <- list('mat'=res$mat, 
                'flashes'=res$flashes, 
                'flashed'=res$flashed)
  } else {
    out <- list('mat'=mat, 
                'flashes'=flashes, 
                'flashed'=flashed)
  }
  
  return(out)
}

step_mat <- function(mat, flashes=0) {
  mat <- mat + 1
  res <- check_flash(mat, flashes)
  return(res)
}

step_multiple <- function(mat, steps=1, flashes=0) {
  
  for (step in 1:steps) {
    res <- step_mat(mat, flashes)
    mat <- res$mat
    flashes <- res$flashes
    # print(str_c('After step ', step,
    #             ' there were ', flashes,
    #             ' flashes.'))
  }
  
  out <- list('mat'=mat, 'flashes'=flashes, 'steps'=steps)
  return(out)
}
```

```{r}
out <- step_multiple(dm, steps=100)
out$flashes
```


## Part 2: when synchronized?
```{r}
find_sync <- function(mat, steps) {
  for (step in 1:steps) {
    res <- step_mat(mat, flashes)
    mat <- res$mat
    flashes <- res$flashes
    if (sum(res$mat==0) == nrow(mat)*ncol(mat) ) {
      print(str_c('First synchronization at step: ', step))
      out <- list('mat'=mat, 'flashes'=flashes, 'steps'=steps)
      return(out)
    }
  }
  print(str_c("Couldn't find sync even after ", steps,
              'steps.'))
  out <- list('mat'=mat, 'flashes'=flashes, 'steps'=steps)
  return(out)
}
```

```{r}
o <- find_sync(dm, steps=1e4)
```

# Day 12: Passage Pathing
We have a list of paths, and need to determine all paths from `start` to `end`.

There are two types of caves. Large caves have CAPITAL letters, and small caves of lowercase letters. We only want to visit small caves once, but can visit large caves any number of times.

```{r}
require(tidyverse)
d_raw <- read_csv('data/aoc-12.txt', col_names='path')
d_raw %>% head()
```

```{r}
d <- d_raw %>%
  separate(path, into=c('s', 'e')) %>%
  mutate(start = case_when(
    str_detect('start', e) ~ e,
    str_detect('end', s) ~ e,
    TRUE ~ s
  )) %>%
  mutate(end = case_when(
    start == s ~ e,
    TRUE ~ s
  )) %>% 
  select(start, end)
d %>% head()
```

```{r}
nodes <- append(d$start, d$end)
nodes <- nodes[! nodes %in% c('start', 'end')]
nodes <- unique(nodes)

is_upper <- function(x) {
  return(!is.na(str_match(x, "^[A-Z]+$")))
}

# return all children of the given parent
get_children <- function(d, parent) {
  children <- d %>%
    filter(start %in% parent | end %in% parent) %>%
    mutate(out = case_when(
      start == parent ~ end, 
      TRUE ~ start)) %>%
    filter(out != 'start') %>%
    select(out) %>% pull()
  return(children)
}

# determine if node is a valid addition to path
check_child <- function(path, node) {
  if (node == 'end')
    return(TRUE)
  if (node %>% is_upper()) 
    return(TRUE)
  else
    if (! node %in% path)
      return(TRUE)
  return(FALSE)
}

add_children <- function(d, paths) {
  nid <- max(sapply(paths, length))
  
  for (pid in 1:length(paths)) {
    p <- paths[[pid]]
    if (p[length(p)] == 'end') {
      # great
    } else {
      children <- get_children(d, p[length(p)])
      for (c in children) {
        if (check_child(p, c)) {
          paths[[length(paths)+1]] <- append(p, c)
        }
      }
    }
  }
  # remove any paths that are too short
  bad_paths <- NULL
  for (ii in 1:length(paths)) {
    p <- paths[[ii]]
    if (length(p) <= nid) {
      if ( p[length(p)] != 'end') {
        bad_paths <- append(bad_paths, ii)
      }
    }
  }
  if (!is.null(bad_paths)) {
    paths <- paths[-bad_paths]
  }
  return(paths)
}
```

```{r}
# initialize
paths <- add_children(d, list('start'))

# find all paths
while (any(!sapply(paths, function(x) x[length(x)] == 'end'))) {
  paths <- add_children(d, paths)
}

length(paths)
```
## Part 2
Now you can visit a single small cave more than once

```{r}
# determine if node is a valid addition to path
check_child2 <- function(path, node) {
  if (node == 'end')
    return(TRUE)
  if (node %>% is_upper()) 
    return(TRUE)
  else {
    # one small cave can be visited twice
    if (node %in% path) {
      # determine how many times each small cave has
      # already been visited
      small_visits <- path %>% tibble(node = .) %>%
        mutate(Big = is_upper(node)) %>%
        filter(! node == 'start') %>%
        filter(!Big) %>%
        count(node) %>%
        select(n) %>%
        pull()
      # if no cave has been visited more than once
      # it's okay to visit this cave again
      if (all(small_visits == 1))
        return(TRUE)
    } else {
      # node not visited yet, safe to add
      return(TRUE)
    }
  }
    
  return(FALSE)
}


add_children2 <- function(d, paths, n_paths = 0) {
  nid <- max(sapply(paths, length))
  
  new_paths <- 0
  paths_to_remove <- NULL
  for (pid in 1:length(paths)) {
    p <- paths[[pid]]
    if (p[length(p)] == 'end') {
      # great, remove the path
      paths_to_remove <- append(paths_to_remove, pid)
      new_paths <- new_paths + 1
    } else {
      children <- get_children(d, p[length(p)])
      for (c in children) {
        if (check_child2(p, c)) {
          paths[[length(paths)+1]] <- append(p, c)
        }
      }
    }
  }
  
  # remove any paths that are too short
  for (ii in 1:length(paths)) {
    p <- paths[[ii]]
    if (length(p) <= nid) {
      if ( p[length(p)] != 'end') {
        paths_to_remove <- append(paths_to_remove, ii)
      }
    }
  }
  if (!is.null(paths_to_remove)) {
    paths <- paths[-paths_to_remove]
  }
  out <- list('paths'=paths, 'n_paths'=n_paths + new_paths)
  return(out)
}
```

```{r}
# initialize
res <- add_children2(d, list('start'))
```

```{r}
# find all paths
while (any(!sapply(res$paths, 
                   function(x) x[length(x)] == 'end'))) {
  res <- add_children2(d, res$paths, res$n_paths)
}

res$n_paths + length(res$paths)
```

# Day 13:
Folding paper
```{r}
require(tidyverse)
d <- read_csv('data/aoc-12_dots.txt', col_names=c('x','y'))
d %>% head()
f <- read_delim('data/aoc-12_folds.txt', col_names=c('f','a','fold'),
                delim=" ")
folds <- f %>% 
  separate(fold, into=c('axis', 'value')) %>%
  select(axis, value) %>%
  mutate(value = as.numeric(value))
```

```{r}
max(d)
```

```{r}
fold_sheet <- function(d, fold) {
  direction <- fold$axis
  coord <- fold$value
  
  if (direction == 'x') {
    d_folded <- d %>%
      mutate(x = abs(x-coord))
  } else {
    d_folded <- d %>% 
      mutate(y = abs(y-coord))
  }
  return(d_folded)
}
```

```{r}
fold_sheet(d, folds[1,]) %>% 
  unite('merged', x, y) %>% 
  filter(!duplicated(select(., merged))) %>%
  nrow()
```

## Part 2: Finish folding
```{r}
fold_sheet2 <- function(d, fold) {
  direction <- fold$axis
  coord <- fold$value
  
  if (direction == 'x') {
    d_folded <- d %>%
      mutate(x = case_when(
        x < coord ~ x,
        x > coord ~ coord - abs(x-coord),
        TRUE ~ NA_real_
        ))
  } else {
    d_folded <- d %>% 
      mutate(y = case_when(
        y < coord ~ y,
        y > coord ~ coord - abs(y-coord),
        TRUE ~ NA_real_
        ))
  }
  return(d_folded)
}
```

```{r}
folded <- d
for (i in 1:nrow(folds)) {
  folded <- fold_sheet2(folded, folds[i,])
  folded <- folded %>% 
    unite(m, x, y, remove=FALSE) %>%
    filter(!duplicated(select(., m))) %>%
    select(x, y)
}

mrow <- max(folded$y)
mcol <- max(folded$x)
output <- matrix('.', nrow=mrow, ncol=mcol)
for (i in 1:nrow(folded)) {
  coord <- folded[i,]
  output[coord$y, coord$x] <- '#'
}

for (i in 1:nrow(output)) {
  print(toString(output[i,]))
}
```

If you squnt, and recognize the top row is missing, then the letters are:
RPCKFBLR

# Day 14:

Based on the starting input, assess each pair of letters (moving window of length 2) and insert the appropriate character based on the rules.
```{r}
require(tidyverse)
input <- read_csv('data/aoc-14_input.txt', col_names='input')
input %>% head()
rules <- read_delim('data/aoc-14_rules.txt', col_names=c('input','void','out'),
                    col_types = cols(.default=col_character()), delim=' ')
rules <- rules %>% select(-void)
rules %>% head()
```

